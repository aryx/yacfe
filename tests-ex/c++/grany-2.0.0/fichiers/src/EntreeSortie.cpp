/*******************************************************************************
 *
 * Copyright (C) 1999-2000 by Y. Padioleau, G. Cottenceau, P. Garcia,
 *   G. LeGuelvouit, Y. Zemali, S. Crunchant, X. Michard.
 *
 * Please check out README.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation under the terms of the GNU General Public License is hereby 
 * granted. No representations are made about the suitability of this software 
 * for any purpose. It is provided "as is" without express or implied warranty.
 * See the GNU General Public License for more details.
 *
 ******************************************************************************/

#include "EntreeSortie.h"


RegleExclusion* RegleIoManager::lire(istream& is)
{
  RegleCompiler compiler;

  return compiler.parseStream(is);
}

void RegleIoManager::ecrire(const RegleExclusion& reg, ostream& os) const
{
  os << reg.getNom() << "=";
  os << endl;
  os << "(";
  
  for (int i = 0; i < VALENCE; i++)
    {
      os << "(";
      switch(reg.getContrainte(i)) {
      case RegleExclusion::CONTRAINTE_NULLE:  os << "Contrainte_NULLE" ; break;
      case RegleExclusion::CONTRAINTE_MEMEPHI: os << "Contrainte_MEMEPHI"; break;
      case RegleExclusion::CONTRAINTE_PHIINFERIEUR: os << "Contrainte_PHIINFERIEUR" ; break;
      case RegleExclusion::CONTRAINTE_PHIINFSOLIDE: os << "Contrainte_PHIINFSOLIDE" ; break;
      }
      os << "," ;
	  
      switch(reg.getDeplacement(i)) {
      case RegleExclusion::DEPLPOSSIBLE:   os << "Depl_POSSIBLE"  ;break;
      case RegleExclusion::DEPLIMPOSSIBLE: os << "Depl_IMPOSSIBLE";break;
      }
      os << ")";
      
      if ( i != (VALENCE-1)) os << "," << endl;

    }
  os << ");\n";
  
}


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

ostream& operator<<(ostream& os,const list<Frontiere*> &liste)
{
  os << "#Generated by the Pad\n" ;
  os << "$FRONTIERE:\n";

  list<Frontiere*>::const_iterator it;
  for (it = liste.begin(); it != liste.end(); it++)
    {
      Forme* form   = (*it)->getForme();
      Frontiere::TypeParoi typ = (*it)->getTypeParoi();

      os << *form;

      os << ", ";

      switch(typ) {
      case Frontiere::CLASSIQUE:   os << "CLASSIQUE" ; break;
      case Frontiere::GENERATRICE: os << "GENERATRICE" ; break;
      }
      os << ";" << endl;

    }
  return os;
}

istream& operator>>(istream& is,list<Frontiere*> &liste)
{
  FrontiereCompiler compiler;

  // on efface les elements de liste
  list<Frontiere*>::iterator it;
  for (it = liste.begin(); it != liste.end(); it++)
    delete (*it);
  
  liste.clear();

  cout << "about" << endl;

  list<Frontiere*> *lis = compiler.parseStream(is);

  cout << "done" << endl;

  liste = *lis;

  delete lis;

  return is;
}

int StaticIOs::parseMesFrontieres(istream& is, list<Frontiere*> &liste)
{
  FrontiereCompiler compiler;

  // on efface les elements de liste
  list<Frontiere*>::iterator it;
  for (it = liste.begin(); it != liste.end(); it++)
    delete (*it);
  
  liste.clear();

  list<Frontiere*> *lis;
  
  int result = compiler.parseStreamWithResults(is, &lis);

  if (result != 0) return result;

  liste = *lis;
  delete lis;
  return result;
}

int StaticIOs::parseMaScene(istream& is, Scene &scene)
{
  SceneCompiler compiler;

  Scene *sce;
  int result = compiler.parseStreamWithResults(is, &sce);

  if (result != 0) return result;

  scene = *sce;
  delete sce;
  return result;
}

int StaticIOs::parseMaRegle(istream& is, RegleExclusion &regle)
{
  RegleCompiler compiler;

  RegleExclusion *reg;
  int result = compiler.parseStreamWithResults(is, &reg);

  if (result != 0) return result;

  regle = *reg;
  delete reg;
  return result;
}

int StaticIOs::parseMaSimul(istream& is, Automate &autom)
{
  SimulCompiler compiler;

  Automate *aut;
  int result = compiler.parseStreamWithResults(is, &aut);

  if (result != 0) return result;

  autom = *aut;
  delete aut;
  return result;
}

void LigneIoManager::ecrire(const Ligne& el, ostream& os) const
{
  os << "LIGNE(" ;
  os << el.getX1() << "," << el.getY1() << ",";
  os << el.getX2() << "," << el.getY2() << ")";
}


void RectangleIoManager::ecrire(const Rectangle& el, ostream& os) const
{
  os << "RECTANGLE(";
  os << el.getX1() << "," << el.getY1() << ",";
  os << el.getX2() << "," << el.getY2() << ")";
}



void PolygoneIoManager::ecrire(const Polygone& el, ostream& os) const
{
  os << "POLYGONE( " << endl;
	     
  list<Ligne*> ligne = el.getLignes();
  list<Ligne*>::const_iterator it;

  for (it = ligne.begin(); it != ligne.end(); it++)
    {
      os << "    ";
      os << *(*(it));
      if ((++it) != (ligne.end())) os << "," << endl;
      it--;
		 
    }
  os << ")";
}


void EllipseIoManager::ecrire(const Ellipse& el, ostream& os) const
{
  os << "ELLIPSE(";
  os << el.getX()  << "," << el.getY()  << ",";
  os << el.getR1() << "," << el.getR2() << ")";
}


void ArcEllipseIoManager::ecrire(const ArcEllipse& el, ostream& os) const
{
  os << "ARCELLIPSE(";
  os << el.getX()  << "," << el.getY()  << ",";
  os << el.getR1() << "," << el.getR2() << ",";
  os << el.getX1() << "," << el.getY1() << ",";
  os << el.getX2() << "," << el.getY2() << ")";
}




Scene* SceneIoManager::lire(istream& is)
{
  SceneCompiler compiler;
  return compiler.parseStream(is);
}

void SceneIoManager::ecrire(const Scene& el, ostream& os) const
{
  os << "#Generated by the Pad\n" ;
  os << endl;
  
  // Frontiere
  os << el.getTableauFrontiere();
  os << endl;

  {
    // Regles
    os << "$REGLES:\n";

    list<RegleExclusion*> reg = el.getTableauRegleExclusion();
    list<RegleExclusion*>::const_iterator it;
    for (it = reg.begin(); it != reg.end(); it++)
      {
	os << *(*it);
	os << endl;
      }
  }

  {
    os << "$COLORMAP:\n";
    // colormap
	
    os <<"(\n";

    list<Couleur*> arg = el.getTableauCouleur();
    list<Couleur*>::const_iterator it;
    for (it = arg.begin(); it != arg.end(); it++)
      {
	os << "     ";
	os << *(*it);

	if ((++it) != (arg.end())) os << "," << endl;
	it--;
	    
      }

    os << "\n);\n";
	
  }
  os << endl;

  {
    os << "$PHASES:\n";
    // Phase
	
    list<Phase*> arg = el.getTableauPhase();
    list<Phase*>::const_iterator it;
    for (it = arg.begin(); it != arg.end(); it++)
      {
	os << *(*it);
	os << endl;
	    
      }
    os << "\n";
    os << "\n";
	
  }

  {
    os << "$ZONAGE:\n";
    // Le Zonage
    list<Zonage*> arg = el.getTableauZonage();
    list<Zonage*>::const_iterator it;
	
    for (it = arg.begin(); it != arg.end(); it++)
      {
	os << *(*it);
	os << endl;
      }
    os << endl << endl;

  }

  {
    os << "$COLORATION:\n";
    // Le Zonage
    list<Coloration*> arg = el.getTableauColoration();
    list<Coloration*>::const_iterator it;
	
    for (it = arg.begin(); it != arg.end(); it++)
      {
	os << *(*it);
	os << endl;
      }
    os << endl << endl;

  }
  
  {
    Phase* phase_gen = el.getPhaseGeneratrice();

    if (phase_gen != NULL)
      {
	os << "$TYPEGENERATRICE:\n";
	os << phase_gen->getNom();
	os << endl;
      }



  }
      
}



void CouleurIoManager::ecrire(const Couleur& el, ostream& os) const
{
  os << "(";
  os << el.getCouleur()  << "," << el.getRed()  << ",";
  os << el.getGreen() << "," << el.getBlue() << ")";
      
}



void PhaseIoManager::ecrire(const Phase& el, ostream& os) const
{
  os << "NOM=" << el.getNom() << ",\n";
  os << " PHI=" << el.getPhi() << ",\n";
  os << " POND=" << el.getPonderation() << ",\n";
  os << " COUL=" << el.getCouleur() << ",\n";
  os << " REGLES=" << "(" ;

  const list<Phase::RegleEtMode>* arg = el.getRegleEtModeExclusion();
  list<Phase::RegleEtMode>::const_iterator it;
      
  for (it = arg->begin(); it != arg->end(); it++)
    {
      os << "(" << (*it).regle->getNom() << ",";
      if ((*it).mode == RegleExclusion::POST)
	os << "POST";
      else 
	os << "PRE";
      os << ")";

      if ((++it) != (arg->end())) os << ", ";
      it--;
	  
    }
  os << ")," << endl;

  os << " INERTIE= " << el.getInertie() << "," << endl;

  os << " PROPAG= ";
  if (el.getPropagatif())
    os << "VRAI";
  else 
    os << "FAUX";
  os << ";" << endl;


      
      
}




void PonderationIoManager::ecrire(const Ponderation& el, ostream& os) const
{
  os << " (";
  for (int i = 0; i < VALENCE; i++)
    {
      os << el.getPonderation(i);
      if (i != (VALENCE-1)) os << ", ";
    }
      
  os << ")";
}




void ZonageIoManager::ecrire(const Zonage& el, ostream& os) const
{
  os << *(el.getFormeFermee());
  os << ",\n         ";
  os << *(el.getContenuZonage());
  os << ";\n";
}



void ContientHorsSceneIoManager::ecrire(const ContientHorsScene& el, ostream& os) const
{
  os << "HS";
}


void ContientPhaseIoManager::ecrire(const ContientPhase& el, ostream& os) const
{
  ContientPhase working_variable = el;  // because the const assertion will not be true through the call to getPhasePourcent

  const vector<PhasePourcent>* arg = working_variable.getPhasePourcent();
  vector<PhasePourcent>::const_iterator it;
      
  os << "(";

  for (it = arg->begin(); it != arg->end(); it++)
    {
      os <<"(";
      os << ((*it).phase->getNom());
      os << ",";
      os << (*it).pourcentage;
      os << ")";
	  


      if ((++it) != (arg->end())) os << ", ";
      it--;
	  
    }

      
  os << ")";
}


void ColorationIoManager::ecrire(const Coloration& el, ostream& os) const
{
  os << *(el.getFormeFermee());
  os << ",";
  os << el.getCouleur();
  os << ";\n";
}



Automate* AutomateIoManager::lire(istream& is)
{
  SimulCompiler compiler;
  return compiler.parseStream(is);
}

void AutomateIoManager::ecrire(const Automate& el, ostream& os) const
{
  os << "#Generated by the Pad\n" ;
  os << endl;
  
  // Params
  os << "$PARAMETRES:\n";
  os << "NBPAS = " << el.getNbrePas() <<  ";" << endl;
  os << "FREQAFF = " << el.getFreqAff() << ";" << endl;
  os << "DIM = " << el.getDimReseau() << ";" << endl;
  os << "GERME = " << el.getGerme() << ";" << endl;
      
  os << endl;

  {
    // Regles
    os << "$REGLES:\n";

    list<RegleExclusion*> reg = el.getRegleExclusion();
    list<RegleExclusion*>::const_iterator it;
    for (it = reg.begin(); it != reg.end(); it++)
      {
	os << *(*it);
	os << endl;
      }
  }

  os << endl;


  {
    os << "$COLORMAP:\n";
    // colormap
	
    os <<"(\n";

    list<Couleur*> arg = el.getCouleur();
    list<Couleur*>::const_iterator it;
    for (it = arg.begin(); it != arg.end(); it++)
      {
	os << "     ";
	os << *(*it);

	if ((++it) != (arg.end())) os << "," << endl;
	it--;
	    
      }
    os << "\n);\n";
	
  }
  os << endl;

  {
    os << "$PHASES:\n";
    // Phase
	
    list<Phase*> arg = el.getTableauPhase();
    list<Phase*>::const_iterator it;
    for (it = arg.begin(); it != arg.end(); it++)
      {
	os << *(*it);
	os << endl;
	    
      }
    os << "\n";
    os << "\n";
	
  }


  {
    os << "$LOCALISATION:\n";
    os << "(";
    Cellule** tab = el.getTableauCellules();
	
    for (int i = 0; i < el.getDimReseau()*el.getDimReseau(); i++)
      {
	os << *tab[i];
	    
	if (i != (el.getDimReseau()*el.getDimReseau()-1)) os << ",\n";
      }
    os << ");" << endl;

  }
      
}


void CelluleHorsSceneIoManager::ecrire(const CelluleHorsScene& el, ostream& os) const
{
  os << "HS";
}


void CelluleParoiIoManager::ecrire(const CelluleParoi& el, ostream& os) const
{
  os << "CP";
}



void CelluleAvecParticuleIoManager::ecrire(const CelluleAvecParticule& el, ostream& os) const
{
  os << "(" << el.getParticule()->getNumero() << ",";

  Requete req = el.getParticule()->getRequeteCourante();
  switch(req) {
  case RIEN: os << "NC"; break;
  case NORD: os << "N "; break;
  case SUD : os << "S "; break;
  case NE  : os << "NE"; break;
  case NW  : os << "NO"; break;
  case SE  : os << "SE"; break;
  case SW  : os << "SO"; break;
  }
  os << ",";

  os << el.getParticule()->getPhase()->getNom() << ",";
  os << el.getParticule()->getCouleur() << ")";
}

void CelluleGeneratriceIoManager::ecrire(const CelluleGeneratrice& el, ostream& os) const
{
  os << "CG(" << el.getParticule()->getNumero() << ",";

  Requete req = el.getParticule()->getRequeteCourante();
  switch(req) {
  case RIEN: os << "NC"; break;
  case NORD: os << "N "; break;
  case SUD : os << "S "; break;
  case NE  : os << "NE"; break;
  case NW  : os << "NO"; break;
  case SE  : os << "SE"; break;
  case SW  : os << "SO"; break;
  }
  os << ",";

  os << el.getParticule()->getPhase()->getNom() << ",";
  os << el.getParticule()->getCouleur() << ",";
  os << el.getPhaseGeneree()->getNom() << ")";

}






//##############################################################################
// static members
//##############################################################################


