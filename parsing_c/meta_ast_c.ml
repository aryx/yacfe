(* generated by ocamltarzan with: camlp4o -o /tmp/yyy.ml -I pa/ pa_type_conv.cmo pa_vof.cmo  pr_o.cmo /tmp/xxx.ml  *)

open Ast_c

module Parse_info = struct
  let vof_t x =
    Ocaml.VUnit
end

module Common = struct
end

module Ast_cocci = struct
  let vof_fixpos _x =
    Ocaml.VUnit
end

module Token_c = struct
  let vof_comment_like_token _x =
    Ocaml.VUnit
end

let vof_posl (v1, v2) =
  let v1 = Ocaml.vof_int v1
  and v2 = Ocaml.vof_int v2
  in Ocaml.VTuple [ v1; v2 ]
  
let vof_virtual_position (v1, v2) =
  let v1 = Parse_info.vof_t v1
  and v2 = Ocaml.vof_int v2
  in Ocaml.VTuple [ v1; v2 ]
  
let vof_parse_info =
  function
  | OriginTok v1 ->
      let v1 = Parse_info.vof_t v1 in Ocaml.VSum (("OriginTok", [ v1 ]))
  | FakeTok ((v1, v2)) ->
      let v1 = Ocaml.vof_string v1
      and v2 = vof_virtual_position v2
      in Ocaml.VSum (("FakeTok", [ v1; v2 ]))
  | ExpandedTok ((v1, v2)) ->
      let v1 = Parse_info.vof_t v1
      and v2 = vof_virtual_position v2
      in Ocaml.VSum (("ExpandedTok", [ v1; v2 ]))
  | AbstractLineTok v1 ->
      let v1 = Parse_info.vof_t v1
      in Ocaml.VSum (("AbstractLineTok", [ v1 ]))

let rec vof_info x = 
(*
  if !_current_precision.M.full_info
  then Parse_info.vof_info x
  else if !_current_precision.M.token_info
       then 
        Ocaml.VDict [
          "line", Ocaml.VInt (Parse_info.line_of_info x);
          "col", Ocaml.VInt (Parse_info.col_of_info x);
        ]
      else Ocaml.VUnit
*)
  Ocaml.VUnit
  
let vof_il v = Ocaml.vof_list vof_info v

let vof_wrap _of_a (v1, v2) =
  let v1 = _of_a v1 (* and v2 = vof_il v2 *) in
  (*
  Ocaml.VTuple [ v1; v2 ]
  *)
  v1
let vof_wrap2 _of_a (v1, v2) =
  let v1 = _of_a v1 (* and v2 = vof_il v2 *) in
  (*
  Ocaml.VTuple [ v1; v2 ]
  *)
  v1

let rec vof_name =
  function
  | RegularName v1 ->
      let v1 = vof_wrap Ocaml.vof_string v1
      in Ocaml.VSum (("RegularName", [ v1 ]))
  | CppConcatenatedName v1 ->
      let v1 = Ocaml.vof_list (vof_wrap2 (vof_wrap Ocaml.vof_string)) v1
      in Ocaml.VSum (("CppConcatenatedName", [ v1 ]))
  | CppVariadicName v1 ->
      let v1 = vof_wrap Ocaml.vof_string v1
      in Ocaml.VSum (("CppVariadicName", [ v1 ]))
  | CppIdentBuilder ((v1, v2)) ->
      let v1 = vof_wrap Ocaml.vof_string v1
      and v2 = Ocaml.vof_list (vof_wrap2 (vof_wrap Ocaml.vof_string)) v2
      in Ocaml.VSum (("CppIdentBuilder", [ v1; v2 ]))
and vof_fullType (v1, v2) =
  let v1 = vof_typeQualifier v1
  and v2 = vof_typeC v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_typeC v = vof_wrap vof_typeCbis v
and vof_typeCbis =
  function
  | BaseType v1 ->
      let v1 = vof_baseType v1 in Ocaml.VSum (("BaseType", [ v1 ]))
  | Pointer v1 ->
      let v1 = vof_fullType v1 in Ocaml.VSum (("Pointer", [ v1 ]))
  | Array ((v1, v2)) ->
      let v1 = Ocaml.vof_option vof_constExpression v1
      and v2 = vof_fullType v2
      in Ocaml.VSum (("Array", [ v1; v2 ]))
  | FunctionType v1 ->
      let v1 = vof_functionType v1 in Ocaml.VSum (("FunctionType", [ v1 ]))
  | Enum ((v1, v2)) ->
      let v1 = Ocaml.vof_option Ocaml.vof_string v1
      and v2 = vof_enumType v2
      in Ocaml.VSum (("Enum", [ v1; v2 ]))
  | StructUnion ((v1, v2, v3)) ->
      let v1 = vof_structUnion v1
      and v2 = Ocaml.vof_option Ocaml.vof_string v2
      and v3 = vof_structType v3
      in Ocaml.VSum (("StructUnion", [ v1; v2; v3 ]))
  | EnumName v1 ->
      let v1 = Ocaml.vof_string v1 in Ocaml.VSum (("EnumName", [ v1 ]))
  | StructUnionName ((v1, v2)) ->
      let v1 = vof_structUnion v1
      and v2 = Ocaml.vof_string v2
      in Ocaml.VSum (("StructUnionName", [ v1; v2 ]))
  | TypeName ((v1, v2)) ->
      let v1 = vof_name v1
      and v2 = Ocaml.vof_option vof_fullType v2
      in Ocaml.VSum (("TypeName", [ v1; v2 ]))
  | ParenType v1 ->
      let v1 = vof_fullType v1 in Ocaml.VSum (("ParenType", [ v1 ]))
  | TypeOfExpr v1 ->
      let v1 = vof_expression v1 in Ocaml.VSum (("TypeOfExpr", [ v1 ]))
  | TypeOfType v1 ->
      let v1 = vof_fullType v1 in Ocaml.VSum (("TypeOfType", [ v1 ]))
and vof_baseType =
  function
  | Void -> Ocaml.VSum (("Void", []))
  | IntType v1 -> let v1 = vof_intType v1 in Ocaml.VSum (("IntType", [ v1 ]))
  | FloatType v1 ->
      let v1 = vof_floatType v1 in Ocaml.VSum (("FloatType", [ v1 ]))
and vof_intType =
  function
  | CChar -> Ocaml.VSum (("CChar", []))
  | Si v1 -> let v1 = vof_signed v1 in Ocaml.VSum (("Si", [ v1 ]))
and vof_signed (v1, v2) =
  let v1 = vof_sign v1 and v2 = vof_base v2 in Ocaml.VTuple [ v1; v2 ]
and vof_base =
  function
  | CChar2 -> Ocaml.VSum (("CChar2", []))
  | CShort -> Ocaml.VSum (("CShort", []))
  | CInt -> Ocaml.VSum (("CInt", []))
  | CLong -> Ocaml.VSum (("CLong", []))
  | CLongLong -> Ocaml.VSum (("CLongLong", []))
and vof_sign =
  function
  | Signed -> Ocaml.VSum (("Signed", []))
  | UnSigned -> Ocaml.VSum (("UnSigned", []))
and vof_floatType =
  function
  | CFloat -> Ocaml.VSum (("CFloat", []))
  | CDouble -> Ocaml.VSum (("CDouble", []))
  | CLongDouble -> Ocaml.VSum (("CLongDouble", []))
and vof_structUnion =
  function
  | Struct -> Ocaml.VSum (("Struct", []))
  | Union -> Ocaml.VSum (("Union", []))
and vof_structType v = Ocaml.vof_list vof_field v
and vof_field =
  function
  | DeclarationField v1 ->
      let v1 = vof_field_declaration v1
      in Ocaml.VSum (("DeclarationField", [ v1 ]))
  | EmptyField v1 ->
      let v1 = vof_info v1 in Ocaml.VSum (("EmptyField", [ v1 ]))
  | MacroDeclField v1 ->
      let v1 =
        vof_wrap
          (fun (v1, v2) ->
             let v1 = Ocaml.vof_string v1
             and v2 = Ocaml.vof_list (vof_wrap2 vof_argument) v2
             in Ocaml.VTuple [ v1; v2 ])
          v1
      in Ocaml.VSum (("MacroDeclField", [ v1 ]))
  | CppDirectiveStruct v1 ->
      let v1 = vof_cpp_directive v1
      in Ocaml.VSum (("CppDirectiveStruct", [ v1 ]))
  | IfdefStruct v1 ->
      let v1 = vof_ifdef_directive v1 in Ocaml.VSum (("IfdefStruct", [ v1 ]))
and vof_field_declaration =
  function
  | FieldDeclList v1 ->
      let v1 = vof_wrap (Ocaml.vof_list (vof_wrap2 vof_fieldkind)) v1
      in Ocaml.VSum (("FieldDeclList", [ v1 ]))
and vof_fieldkind =
  function
  | Simple ((v1, v2)) ->
      let v1 = Ocaml.vof_option vof_name v1
      and v2 = vof_fullType v2
      in Ocaml.VSum (("Simple", [ v1; v2 ]))
  | BitField ((v1, v2, v3, v4)) ->
      let v1 = Ocaml.vof_option vof_name v1
      and v2 = vof_fullType v2
      and v3 = vof_info v3
      and v4 = vof_constExpression v4
      in Ocaml.VSum (("BitField", [ v1; v2; v3; v4 ]))
and vof_enumType v =
  Ocaml.vof_list
    (vof_wrap2
       (fun (v1, v2) ->
          let v1 = vof_name v1
          and v2 =
            Ocaml.vof_option
              (fun (v1, v2) ->
                 let v1 = vof_info v1
                 and v2 = vof_constExpression v2
                 in Ocaml.VTuple [ v1; v2 ])
              v2
          in Ocaml.VTuple [ v1; v2 ]))
    v
and vof_functionType (v1, v2) =
  let v1 = vof_fullType v1
  and v2 =
    match v2 with
    | (v1, v2) ->
        let v1 = Ocaml.vof_list (vof_wrap2 vof_parameterType) v1
        and v2 = vof_wrap Ocaml.vof_bool v2
        in Ocaml.VTuple [ v1; v2 ]
  in Ocaml.VTuple [ v1; v2 ]
and
  vof_parameterType {
                      p_namei = v_p_namei;
                      p_register = v_p_register;
                      p_type = v_p_type
                    } =
  let bnds = [] in
  let arg = vof_fullType v_p_type in
  let bnd = ("p_type", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_wrap Ocaml.vof_bool v_p_register in
  let bnd = ("p_register", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_option vof_name v_p_namei in
  let bnd = ("p_namei", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_typeQualifier v = vof_wrap vof_typeQualifierbis v
and vof_typeQualifierbis { const = v_const; volatile = v_volatile } =
  let bnds = [] in
  let arg = Ocaml.vof_bool v_volatile in
  let bnd = ("volatile", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_bool v_const in
  let bnd = ("const", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_attribute v = vof_wrap vof_attributebis v
and vof_attributebis =
  function
  | Attribute v1 ->
      let v1 = Ocaml.vof_string v1 in Ocaml.VSum (("Attribute", [ v1 ]))
and vof_expression v =
  vof_wrap
    (fun (v1, v2) ->
       let v1 = vof_expressionbis v1
       and v2 = Ocaml.vof_ref vof_exp_info v2
       in Ocaml.VTuple [ v1; v2 ])
    v
and vof_exp_info (v1, v2) =
  let v1 = Ocaml.vof_option vof_exp_type v1
  and v2 = vof_test v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_exp_type (v1, v2) =
  let v1 = vof_fullType v1 and v2 = vof_local v2 in Ocaml.VTuple [ v1; v2 ]
and vof_local =
  function
  | LocalVar v1 ->
      let v1 = vof_parse_info v1 in Ocaml.VSum (("LocalVar", [ v1 ]))
  | NotLocalVar -> Ocaml.VSum (("NotLocalVar", []))
and vof_test =
  function
  | Test -> Ocaml.VSum (("Test", []))
  | NotTest -> Ocaml.VSum (("NotTest", []))
and vof_expressionbis =
  function
  | Ident v1 -> let v1 = vof_name v1 in Ocaml.VSum (("Ident", [ v1 ]))
  | Constant v1 ->
      let v1 = vof_constant v1 in Ocaml.VSum (("Constant", [ v1 ]))
  | FunCall ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = Ocaml.vof_list (vof_wrap2 vof_argument) v2
      in Ocaml.VSum (("FunCall", [ v1; v2 ]))
  | CondExpr ((v1, v2, v3)) ->
      let v1 = vof_expression v1
      and v2 = Ocaml.vof_option vof_expression v2
      and v3 = vof_expression v3
      in Ocaml.VSum (("CondExpr", [ v1; v2; v3 ]))
  | Sequence ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_expression v2
      in Ocaml.VSum (("Sequence", [ v1; v2 ]))
  | Assignment ((v1, v2, v3)) ->
      let v1 = vof_expression v1
      and v2 = vof_assignOp v2
      and v3 = vof_expression v3
      in Ocaml.VSum (("Assignment", [ v1; v2; v3 ]))
  | Postfix ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_fixOp v2
      in Ocaml.VSum (("Postfix", [ v1; v2 ]))
  | Infix ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_fixOp v2
      in Ocaml.VSum (("Infix", [ v1; v2 ]))
  | Unary ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_unaryOp v2
      in Ocaml.VSum (("Unary", [ v1; v2 ]))
  | Binary ((v1, v2, v3)) ->
      let v1 = vof_expression v1
      and v2 = vof_binaryOp v2
      and v3 = vof_expression v3
      in Ocaml.VSum (("Binary", [ v1; v2; v3 ]))
  | ArrayAccess ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_expression v2
      in Ocaml.VSum (("ArrayAccess", [ v1; v2 ]))
  | RecordAccess ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_name v2
      in Ocaml.VSum (("RecordAccess", [ v1; v2 ]))
  | RecordPtAccess ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_name v2
      in Ocaml.VSum (("RecordPtAccess", [ v1; v2 ]))
  | SizeOfExpr v1 ->
      let v1 = vof_expression v1 in Ocaml.VSum (("SizeOfExpr", [ v1 ]))
  | SizeOfType v1 ->
      let v1 = vof_fullType v1 in Ocaml.VSum (("SizeOfType", [ v1 ]))
  | Cast ((v1, v2)) ->
      let v1 = vof_fullType v1
      and v2 = vof_expression v2
      in Ocaml.VSum (("Cast", [ v1; v2 ]))
  | StatementExpr v1 ->
      let v1 = vof_wrap vof_compound v1
      in Ocaml.VSum (("StatementExpr", [ v1 ]))
  | Constructor ((v1, v2)) ->
      let v1 = vof_fullType v1
      and v2 = Ocaml.vof_list (vof_wrap2 vof_initialiser) v2
      in Ocaml.VSum (("Constructor", [ v1; v2 ]))
  | ParenExpr v1 ->
      let v1 = vof_expression v1 in Ocaml.VSum (("ParenExpr", [ v1 ]))
and vof_argument v = Ocaml.vof_either vof_expression vof_weird_argument v
and vof_weird_argument =
  function
  | ArgType v1 ->
      let v1 = vof_parameterType v1 in Ocaml.VSum (("ArgType", [ v1 ]))
  | ArgAction v1 ->
      let v1 = vof_action_macro v1 in Ocaml.VSum (("ArgAction", [ v1 ]))
and vof_action_macro =
  function
  | ActMisc v1 -> let v1 = vof_il v1 in Ocaml.VSum (("ActMisc", [ v1 ]))
and vof_constant =
  function
  | String v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) ->
             let v1 = Ocaml.vof_string v1
             and v2 = vof_isWchar v2
             in Ocaml.VTuple [ v1; v2 ])
      in Ocaml.VSum (("String", [ v1 ]))
  | MultiString v1 ->
      let v1 = Ocaml.vof_list Ocaml.vof_string v1
      in Ocaml.VSum (("MultiString", [ v1 ]))
  | Char v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) ->
             let v1 = Ocaml.vof_string v1
             and v2 = vof_isWchar v2
             in Ocaml.VTuple [ v1; v2 ])
      in Ocaml.VSum (("Char", [ v1 ]))
  | Int v1 -> let v1 = Ocaml.vof_string v1 in Ocaml.VSum (("Int", [ v1 ]))
  | Float v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) ->
             let v1 = Ocaml.vof_string v1
             and v2 = vof_floatType v2
             in Ocaml.VTuple [ v1; v2 ])
      in Ocaml.VSum (("Float", [ v1 ]))
and vof_isWchar =
  function
  | IsWchar -> Ocaml.VSum (("IsWchar", []))
  | IsChar -> Ocaml.VSum (("IsChar", []))
and vof_unaryOp =
  function
  | GetRef -> Ocaml.VSum (("GetRef", []))
  | DeRef -> Ocaml.VSum (("DeRef", []))
  | UnPlus -> Ocaml.VSum (("UnPlus", []))
  | UnMinus -> Ocaml.VSum (("UnMinus", []))
  | Tilde -> Ocaml.VSum (("Tilde", []))
  | Not -> Ocaml.VSum (("Not", []))
  | GetRefLabel -> Ocaml.VSum (("GetRefLabel", []))
and vof_assignOp =
  function
  | SimpleAssign -> Ocaml.VSum (("SimpleAssign", []))
  | OpAssign v1 ->
      let v1 = vof_arithOp v1 in Ocaml.VSum (("OpAssign", [ v1 ]))
and vof_fixOp =
  function
  | Dec -> Ocaml.VSum (("Dec", []))
  | Inc -> Ocaml.VSum (("Inc", []))
and vof_binaryOp =
  function
  | Arith v1 -> let v1 = vof_arithOp v1 in Ocaml.VSum (("Arith", [ v1 ]))
  | Logical v1 ->
      let v1 = vof_logicalOp v1 in Ocaml.VSum (("Logical", [ v1 ]))
and vof_arithOp =
  function
  | Plus -> Ocaml.VSum (("Plus", []))
  | Minus -> Ocaml.VSum (("Minus", []))
  | Mul -> Ocaml.VSum (("Mul", []))
  | Div -> Ocaml.VSum (("Div", []))
  | Mod -> Ocaml.VSum (("Mod", []))
  | DecLeft -> Ocaml.VSum (("DecLeft", []))
  | DecRight -> Ocaml.VSum (("DecRight", []))
  | And -> Ocaml.VSum (("And", []))
  | Or -> Ocaml.VSum (("Or", []))
  | Xor -> Ocaml.VSum (("Xor", []))
and vof_logicalOp =
  function
  | Inf -> Ocaml.VSum (("Inf", []))
  | Sup -> Ocaml.VSum (("Sup", []))
  | InfEq -> Ocaml.VSum (("InfEq", []))
  | SupEq -> Ocaml.VSum (("SupEq", []))
  | Eq -> Ocaml.VSum (("Eq", []))
  | NotEq -> Ocaml.VSum (("NotEq", []))
  | AndLog -> Ocaml.VSum (("AndLog", []))
  | OrLog -> Ocaml.VSum (("OrLog", []))
and vof_constExpression v = vof_expression v
and vof_statement v = vof_wrap vof_statementbis v
and vof_statementbis =
  function
  | Labeled v1 -> let v1 = vof_labeled v1 in Ocaml.VSum (("Labeled", [ v1 ]))
  | Compound v1 ->
      let v1 = vof_compound v1 in Ocaml.VSum (("Compound", [ v1 ]))
  | ExprStatement v1 ->
      let v1 = vof_exprStatement v1 in Ocaml.VSum (("ExprStatement", [ v1 ]))
  | Selection v1 ->
      let v1 = vof_selection v1 in Ocaml.VSum (("Selection", [ v1 ]))
  | Iteration v1 ->
      let v1 = vof_iteration v1 in Ocaml.VSum (("Iteration", [ v1 ]))
  | Jump v1 -> let v1 = vof_jump v1 in Ocaml.VSum (("Jump", [ v1 ]))
  | Decl v1 -> let v1 = vof_declaration v1 in Ocaml.VSum (("Decl", [ v1 ]))
  | Asm v1 -> let v1 = vof_asmbody v1 in Ocaml.VSum (("Asm", [ v1 ]))
  | NestedFunc v1 ->
      let v1 = vof_definition v1 in Ocaml.VSum (("NestedFunc", [ v1 ]))
  | MacroStmt -> Ocaml.VSum (("MacroStmt", []))
and vof_labeled =
  function
  | Label ((v1, v2)) ->
      let v1 = vof_name v1
      and v2 = vof_statement v2
      in Ocaml.VSum (("Label", [ v1; v2 ]))
  | Case ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_statement v2
      in Ocaml.VSum (("Case", [ v1; v2 ]))
  | CaseRange ((v1, v2, v3)) ->
      let v1 = vof_expression v1
      and v2 = vof_expression v2
      and v3 = vof_statement v3
      in Ocaml.VSum (("CaseRange", [ v1; v2; v3 ]))
  | Default v1 ->
      let v1 = vof_statement v1 in Ocaml.VSum (("Default", [ v1 ]))
and vof_compound v = Ocaml.vof_list vof_statement_sequencable v
and vof_statement_sequencable =
  function
  | StmtElem v1 ->
      let v1 = vof_statement v1 in Ocaml.VSum (("StmtElem", [ v1 ]))
  | CppDirectiveStmt v1 ->
      let v1 = vof_cpp_directive v1
      in Ocaml.VSum (("CppDirectiveStmt", [ v1 ]))
  | IfdefStmt v1 ->
      let v1 = vof_ifdef_directive v1 in Ocaml.VSum (("IfdefStmt", [ v1 ]))
  | IfdefStmt2 ((v1, v2)) ->
      let v1 = Ocaml.vof_list vof_ifdef_directive v1
      and v2 = Ocaml.vof_list (Ocaml.vof_list vof_statement_sequencable) v2
      in Ocaml.VSum (("IfdefStmt2", [ v1; v2 ]))
and vof_exprStatement v = Ocaml.vof_option vof_expression v
and vof_selection =
  function
  | If ((v1, v2, v3)) ->
      let v1 = vof_expression v1
      and v2 = vof_statement v2
      and v3 = vof_statement v3
      in Ocaml.VSum (("If", [ v1; v2; v3 ]))
  | Switch ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_statement v2
      in Ocaml.VSum (("Switch", [ v1; v2 ]))
and vof_iteration =
  function
  | While ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_statement v2
      in Ocaml.VSum (("While", [ v1; v2 ]))
  | DoWhile ((v1, v2)) ->
      let v1 = vof_statement v1
      and v2 = vof_expression v2
      in Ocaml.VSum (("DoWhile", [ v1; v2 ]))
  | For ((v1, v2, v3, v4)) ->
      let v1 = vof_wrap vof_exprStatement v1
      and v2 = vof_wrap vof_exprStatement v2
      and v3 = vof_wrap vof_exprStatement v3
      and v4 = vof_statement v4
      in Ocaml.VSum (("For", [ v1; v2; v3; v4 ]))
  | MacroIteration ((v1, v2, v3)) ->
      let v1 = Ocaml.vof_string v1
      and v2 = Ocaml.vof_list (vof_wrap2 vof_argument) v2
      and v3 = vof_statement v3
      in Ocaml.VSum (("MacroIteration", [ v1; v2; v3 ]))
and vof_jump =
  function
  | Goto v1 -> let v1 = vof_name v1 in Ocaml.VSum (("Goto", [ v1 ]))
  | Continue -> Ocaml.VSum (("Continue", []))
  | Break -> Ocaml.VSum (("Break", []))
  | Return -> Ocaml.VSum (("Return", []))
  | ReturnExpr v1 ->
      let v1 = vof_expression v1 in Ocaml.VSum (("ReturnExpr", [ v1 ]))
  | GotoComputed v1 ->
      let v1 = vof_expression v1 in Ocaml.VSum (("GotoComputed", [ v1 ]))
and vof_asmbody (v1, v2) =
  let v1 = vof_il v1
  and v2 = Ocaml.vof_list (vof_wrap vof_colon) v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_colon =
  function
  | Colon v1 ->
      let v1 = Ocaml.vof_list (vof_wrap2 vof_colon_option) v1
      in Ocaml.VSum (("Colon", [ v1 ]))
and vof_colon_option v = vof_wrap vof_colon_option_bis v
and vof_colon_option_bis =
  function
  | ColonMisc -> Ocaml.VSum (("ColonMisc", []))
  | ColonExpr v1 ->
      let v1 = vof_expression v1 in Ocaml.VSum (("ColonExpr", [ v1 ]))
and vof_declaration =
  function
  | DeclList v1 ->
      let v1 = vof_wrap (Ocaml.vof_list (vof_wrap2 vof_onedecl)) v1
      in Ocaml.VSum (("DeclList", [ v1 ]))
  | MacroDecl v1 ->
      let v1 =
        vof_wrap
          (fun (v1, v2) ->
             let v1 = Ocaml.vof_string v1
             and v2 = Ocaml.vof_list (vof_wrap2 vof_argument) v2
             in Ocaml.VTuple [ v1; v2 ])
          v1
      in Ocaml.VSum (("MacroDecl", [ v1 ]))
and
  vof_onedecl {
                v_namei = v_v_namei;
                v_type = v_v_type;
                v_storage = v_v_storage;
                v_local = v_v_local;
                v_attr = v_v_attr
              } =
  let bnds = [] in
  let arg = Ocaml.vof_list vof_attribute v_v_attr in
  let bnd = ("v_attr", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_local_decl v_v_local in
  let bnd = ("v_local", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_storage v_v_storage in
  let bnd = ("v_storage", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_fullType v_v_type in
  let bnd = ("v_type", arg) in
  let bnds = bnd :: bnds in
  let arg =
    Ocaml.vof_option
      (fun (v1, v2) ->
         let v1 = vof_name v1
         and v2 =
           Ocaml.vof_option
             (fun (v1, v2) ->
                let v1 = vof_info v1
                and v2 = vof_initialiser v2
                in Ocaml.VTuple [ v1; v2 ])
             v2
         in Ocaml.VTuple [ v1; v2 ])
      v_v_namei in
  let bnd = ("v_namei", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_storage (v1, v2) =
  let v1 = vof_storagebis v1
  and v2 = Ocaml.vof_bool v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_storagebis =
  function
  | NoSto -> Ocaml.VSum (("NoSto", []))
  | StoTypedef -> Ocaml.VSum (("StoTypedef", []))
  | Sto v1 -> let v1 = vof_storageClass v1 in Ocaml.VSum (("Sto", [ v1 ]))
and vof_storageClass =
  function
  | Auto -> Ocaml.VSum (("Auto", []))
  | Static -> Ocaml.VSum (("Static", []))
  | Register -> Ocaml.VSum (("Register", []))
  | Extern -> Ocaml.VSum (("Extern", []))
and vof_local_decl =
  function
  | LocalDecl -> Ocaml.VSum (("LocalDecl", []))
  | NotLocalDecl -> Ocaml.VSum (("NotLocalDecl", []))
and vof_initialiser v = vof_wrap vof_initialiserbis v
and vof_initialiserbis =
  function
  | InitExpr v1 ->
      let v1 = vof_expression v1 in Ocaml.VSum (("InitExpr", [ v1 ]))
  | InitList v1 ->
      let v1 = Ocaml.vof_list (vof_wrap2 vof_initialiser) v1
      in Ocaml.VSum (("InitList", [ v1 ]))
  | InitDesignators ((v1, v2)) ->
      let v1 = Ocaml.vof_list vof_designator v1
      and v2 = vof_initialiser v2
      in Ocaml.VSum (("InitDesignators", [ v1; v2 ]))
  | InitFieldOld ((v1, v2)) ->
      let v1 = Ocaml.vof_string v1
      and v2 = vof_initialiser v2
      in Ocaml.VSum (("InitFieldOld", [ v1; v2 ]))
  | InitIndexOld ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_initialiser v2
      in Ocaml.VSum (("InitIndexOld", [ v1; v2 ]))
and vof_designator v = vof_wrap vof_designatorbis v
and vof_designatorbis =
  function
  | DesignatorField v1 ->
      let v1 = Ocaml.vof_string v1
      in Ocaml.VSum (("DesignatorField", [ v1 ]))
  | DesignatorIndex v1 ->
      let v1 = vof_expression v1 in Ocaml.VSum (("DesignatorIndex", [ v1 ]))
  | DesignatorRange ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_expression v2
      in Ocaml.VSum (("DesignatorRange", [ v1; v2 ]))
and vof_definition v = vof_wrap vof_definitionbis v
and
  vof_definitionbis {
                      f_name = v_f_name;
                      f_type = v_f_type;
                      f_storage = v_f_storage;
                      f_body = v_f_body;
                      f_attr = v_f_attr;
                      f_old_c_style = v_f_old_c_style
                    } =
  let bnds = [] in
  let arg =
    Ocaml.vof_option (Ocaml.vof_list vof_declaration) v_f_old_c_style in
  let bnd = ("f_old_c_style", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_list vof_attribute v_f_attr in
  let bnd = ("f_attr", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_compound v_f_body in
  let bnd = ("f_body", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_storage v_f_storage in
  let bnd = ("f_storage", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_functionType v_f_type in
  let bnd = ("f_type", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_name v_f_name in
  let bnd = ("f_name", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_cpp_directive =
  function
  | Define v1 -> let v1 = vof_define v1 in Ocaml.VSum (("Define", [ v1 ]))
  | Include v1 -> let v1 = vof_includ v1 in Ocaml.VSum (("Include", [ v1 ]))
  | Undef v1 ->
      let v1 = vof_wrap Ocaml.vof_string v1 in Ocaml.VSum (("Undef", [ v1 ]))
  | PragmaAndCo v1 ->
      let v1 = vof_il v1 in Ocaml.VSum (("PragmaAndCo", [ v1 ]))
and vof_define (v1, v2) =
  let v1 = vof_wrap Ocaml.vof_string v1
  and v2 =
    match v2 with
    | (v1, v2) ->
        let v1 = vof_define_kind v1
        and v2 = vof_define_val v2
        in Ocaml.VTuple [ v1; v2 ]
  in Ocaml.VTuple [ v1; v2 ]
and vof_define_kind =
  function
  | DefineVar -> Ocaml.VSum (("DefineVar", []))
  | DefineFunc v1 ->
      let v1 =
        vof_wrap (Ocaml.vof_list (vof_wrap2 (vof_wrap Ocaml.vof_string))) v1
      in Ocaml.VSum (("DefineFunc", [ v1 ]))
and vof_define_val =
  function
  | DefineExpr v1 ->
      let v1 = vof_expression v1 in Ocaml.VSum (("DefineExpr", [ v1 ]))
  | DefineStmt v1 ->
      let v1 = vof_statement v1 in Ocaml.VSum (("DefineStmt", [ v1 ]))
  | DefineType v1 ->
      let v1 = vof_fullType v1 in Ocaml.VSum (("DefineType", [ v1 ]))
  | DefineDoWhileZero v1 ->
      let v1 =
        vof_wrap
          (fun (v1, v2) ->
             let v1 = vof_statement v1
             and v2 = vof_expression v2
             in Ocaml.VTuple [ v1; v2 ])
          v1
      in Ocaml.VSum (("DefineDoWhileZero", [ v1 ]))
  | DefineFunction v1 ->
      let v1 = vof_definition v1 in Ocaml.VSum (("DefineFunction", [ v1 ]))
  | DefineInit v1 ->
      let v1 = vof_initialiser v1 in Ocaml.VSum (("DefineInit", [ v1 ]))
  | DefineText v1 ->
      let v1 = vof_wrap Ocaml.vof_string v1
      in Ocaml.VSum (("DefineText", [ v1 ]))
  | DefineEmpty -> Ocaml.VSum (("DefineEmpty", []))
  | DefineTodo -> Ocaml.VSum (("DefineTodo", []))
and
  vof_includ {
               i_include = v_i_include;
               i_rel_pos = v_i_rel_pos;
               i_is_in_ifdef = v_i_is_in_ifdef;
               i_content = v_i_content
             } =
  let bnds = [] in
  let arg =
    Ocaml.vof_option
      (fun (v1, v2) ->
         let v1 = Ocaml.vof_string v1
         and v2 = vof_program v2
         in Ocaml.VTuple [ v1; v2 ])
      v_i_content in
  let bnd = ("i_content", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_bool v_i_is_in_ifdef in
  let bnd = ("i_is_in_ifdef", arg) in
  let bnds = bnd :: bnds in
  let arg =
    Ocaml.vof_ref (Ocaml.vof_option vof_include_rel_pos) v_i_rel_pos in
  let bnd = ("i_rel_pos", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_wrap vof_inc_file v_i_include in
  let bnd = ("i_include", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_inc_file =
  function
  | Local v1 ->
      let v1 = Ocaml.vof_list vof_inc_elem v1
      in Ocaml.VSum (("Local", [ v1 ]))
  | NonLocal v1 ->
      let v1 = Ocaml.vof_list vof_inc_elem v1
      in Ocaml.VSum (("NonLocal", [ v1 ]))
  | Weird v1 ->
      let v1 = Ocaml.vof_string v1 in Ocaml.VSum (("Weird", [ v1 ]))
and vof_inc_elem v = Ocaml.vof_string v
and vof_include_rel_pos { first_of = v_first_of; last_of = v_last_of } =
  let bnds = [] in
  let arg = Ocaml.vof_list (Ocaml.vof_list Ocaml.vof_string) v_last_of in
  let bnd = ("last_of", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_list (Ocaml.vof_list Ocaml.vof_string) v_first_of in
  let bnd = ("first_of", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_ifdef_directive =
  function
  | IfdefDirective v1 ->
      let v1 =
        vof_wrap
          (fun (v1, v2) ->
             let v1 = vof_ifdefkind v1
             and v2 = vof_matching_tag v2
             in Ocaml.VTuple [ v1; v2 ])
          v1
      in Ocaml.VSum (("IfdefDirective", [ v1 ]))
and vof_ifdefkind =
  function
  | Ifdef -> Ocaml.VSum (("Ifdef", []))
  | IfdefElseif -> Ocaml.VSum (("IfdefElseif", []))
  | IfdefElse -> Ocaml.VSum (("IfdefElse", []))
  | IfdefEndif -> Ocaml.VSum (("IfdefEndif", []))
and vof_matching_tag =
  function
  | IfdefTag v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) ->
             let v1 = Ocaml.vof_int v1
             and v2 = Ocaml.vof_int v2
             in Ocaml.VTuple [ v1; v2 ])
      in Ocaml.VSum (("IfdefTag", [ v1 ]))
and vof_toplevel =
  function
  | Declaration v1 ->
      let v1 = vof_declaration v1 in Ocaml.VSum (("Declaration", [ v1 ]))
  | Definition v1 ->
      let v1 = vof_definition v1 in Ocaml.VSum (("Definition", [ v1 ]))
  | CppTop v1 ->
      let v1 = vof_cpp_directive v1 in Ocaml.VSum (("CppTop", [ v1 ]))
  | IfdefTop v1 ->
      let v1 = vof_ifdef_directive v1 in Ocaml.VSum (("IfdefTop", [ v1 ]))
  | MacroTop ((v1, v2, v3)) ->
      let v1 = Ocaml.vof_string v1
      and v2 = Ocaml.vof_list (vof_wrap2 vof_argument) v2
      and v3 = vof_il v3
      in Ocaml.VSum (("MacroTop", [ v1; v2; v3 ]))
  | EmptyDef v1 -> let v1 = vof_il v1 in Ocaml.VSum (("EmptyDef", [ v1 ]))
  | NotParsedCorrectly v1 ->
      let v1 = vof_il v1 in Ocaml.VSum (("NotParsedCorrectly", [ v1 ]))
  | FinalDef v1 -> let v1 = vof_info v1 in Ocaml.VSum (("FinalDef", [ v1 ]))
and vof_program v = Ocaml.vof_list vof_toplevel v
and vof_metavars_binding v =
  Ocaml.VUnit
(*
  vof_assoc Ast_cocci.vof_meta_name vof_metavar_binding_kind v
*)
and vof_metavar_binding_kind =
  function
  | MetaIdVal v1 ->
      let v1 = Ocaml.vof_string v1 in Ocaml.VSum (("MetaIdVal", [ v1 ]))
  | MetaFuncVal v1 ->
      let v1 = Ocaml.vof_string v1 in Ocaml.VSum (("MetaFuncVal", [ v1 ]))
  | MetaLocalFuncVal v1 ->
      let v1 = Ocaml.vof_string v1
      in Ocaml.VSum (("MetaLocalFuncVal", [ v1 ]))
  | MetaExprVal v1 ->
      let v1 = vof_expression v1 in Ocaml.VSum (("MetaExprVal", [ v1 ]))
  | MetaExprListVal v1 ->
      let v1 = Ocaml.vof_list (vof_wrap2 vof_argument) v1
      in Ocaml.VSum (("MetaExprListVal", [ v1 ]))
  | MetaParamVal v1 ->
      let v1 = vof_parameterType v1 in Ocaml.VSum (("MetaParamVal", [ v1 ]))
  | MetaParamListVal v1 ->
      let v1 = Ocaml.vof_list (vof_wrap2 vof_parameterType) v1
      in Ocaml.VSum (("MetaParamListVal", [ v1 ]))
  | MetaTypeVal v1 ->
      let v1 = vof_fullType v1 in Ocaml.VSum (("MetaTypeVal", [ v1 ]))
  | MetaInitVal v1 ->
      let v1 = vof_initialiser v1 in Ocaml.VSum (("MetaInitVal", [ v1 ]))
  | MetaStmtVal v1 ->
      let v1 = vof_statement v1 in Ocaml.VSum (("MetaStmtVal", [ v1 ]))
  | MetaPosVal v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) ->
             let v1 = Ast_cocci.vof_fixpos v1
             and v2 = Ast_cocci.vof_fixpos v2
             in Ocaml.VTuple [ v1; v2 ])
      in Ocaml.VSum (("MetaPosVal", [ v1 ]))
  | MetaPosValList v1 ->
      let v1 =
        Ocaml.vof_list
          (fun (v1, v2, v3, v4) ->
             let v1 = Ocaml.vof_string v1
             and v2 = Ocaml.vof_string v2
             and v3 = vof_posl v3
             and v4 = vof_posl v4
             in Ocaml.VTuple [ v1; v2; v3; v4 ])
          v1
      in Ocaml.VSum (("MetaPosValList", [ v1 ]))
  | MetaListlenVal v1 ->
      let v1 = Ocaml.vof_int v1 in Ocaml.VSum (("MetaListlenVal", [ v1 ]))
and
  vof_comments_around {
                        mbefore = v_mbefore;
                        mafter = v_mafter;
                        mbefore2 = v_mbefore2;
                        mafter2 = v_mafter2
                      } =
  let bnds = [] in
  let arg = Ocaml.vof_list vof_comment_and_relative_pos v_mafter2 in
  let bnd = ("mafter2", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_list vof_comment_and_relative_pos v_mbefore2 in
  let bnd = ("mbefore2", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_list Token_c.vof_comment_like_token v_mafter in
  let bnd = ("mafter", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_list Token_c.vof_comment_like_token v_mbefore in
  let bnd = ("mbefore", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_comment_and_relative_pos { minfo = v_minfo; mpos = v_mpos } =
  let bnds = [] in
  let arg = Ocaml.vof_int v_mpos in
  let bnd = ("mpos", arg) in
  let bnds = bnd :: bnds in
  let arg = Parse_info.vof_t v_minfo in
  let bnd = ("minfo", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_comment v = Parse_info.vof_t v
and vof_com v = Ocaml.vof_ref (Ocaml.vof_list vof_comment) v
  
