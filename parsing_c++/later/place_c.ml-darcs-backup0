(* was in of ccomment/comments/comments_extraction.ml *)


(* ------------------------------------------------------------------------- *)
(* The place, the comment is next to a xxx C entity *)
(* ------------------------------------------------------------------------- *)
(* We also associate to the place the C entity it refers too. Can be useful
 * then for instance to see if there is multiple times a comment referencing
 * the same entity.
 *
 * todo? make difference between macroVar that expand to constant and
 * the one that expands to complex code ? 
 *)

type place = 
  | Header (* file/module comment *)

  (* ------------------- *)
  (* big entities *)

  | Function of string
  | Variable of string
  | Prototype of string

  (* c++ext: 
  | Class
  | Method
  *)





  (* ------------------- *)
  (* cppext: *)

  (* #define *)
  | MacroFunction of string
  | MacroVariable of string

  (* #ifdef, make difference between the different kind ? cst, version, etc*)
  | IfDef 

  (* #include *)
  | Include of string

  (* ------------------- *)
  (* type related *)

  (* add type ? maybe can detect that put lots of comments on int *)
  | Struct of string 
  | Field of string
  | StructIdent (* as in struct /* xxx */ { }, often seen in sparse code *)

  | Enum of string
  | EnumValue of string


  (* ------------------- *)
  | Parameter (* type ? *)

  | Type

  | Initializer

  (* ------------------- *)
  (* less? associate the statement ? *)
  | Statement of statement_place
  | Expression of expression_place


  (* ------------------- *)
  (* end of stuff *)

  | EndCompound
  | Else 

  (* cppext: *)
  | IfdefElse (* or elsif *)
  | IfdefEndif


  | EndOfFile

  (* ------------------- *)
  (* fallthrough *)
  | InInitializerUnknown 
  | InStructUnknown
  | InEnumUnknown
  | InFuncUnknown

  | Unknown
  | Fake (* fake comments but to have opportunity to have objects other
          * than comments in the LFS database
          *)

 and statement_place = 
   | If
   | Loop (* for, while, iterator *)

   | SimpleFunCall of string
   | SimpleAssign of string
   | SimpleFieldAssign of string

   | MethodCall of string (* xxx.foo(); pointer function call =~ method call *)

   | SimpleAssignOp of Ast_c.arithOp
   | SimpleIncDec of Ast_c.fixOp

   | Label of string (* often used as exception handler in Linux *)
   | Case of string option

   | Goto of string
   | Break
   | Continue
   | Return

   | Compound

   | StatementUnknown

 and expression_place = 
   | Binary of Ast_c.binaryOp

   | ExpressionUnknown


let s_of_arithop op = 
  match op with
  | Ast_c.Plus | Ast_c.Minus -> "plusminus"
  | Ast_c.Mul | Ast_c.Div | Ast_c.Mod -> "muldiv"
  | Ast_c.DecLeft | Ast_c.DecRight  -> "shift"
  | Ast_c.And | Ast_c.Or | Ast_c.Xor -> "logic"


(* the string option is the optional C entity the comments is next to *)
let (s_of_place : place -> string * string option) = function
  | Header -> "header", None

  | Function s  -> "function", Some s
  | Variable s -> "variable", Some s
  | Prototype s  -> "prototype", Some s

  | MacroFunction s -> "macro_function", Some s
  | MacroVariable s -> "macro_variable", Some s

  | IfDef -> "ifdef", None
  | Include s -> "include", Some s

  | Parameter -> "parameter", None

  | Type -> "type", None

  | Initializer -> "initializer", None

  | Struct s -> "struct", Some s
  | Field s -> "field", Some s
  | StructIdent -> "structident", None

  | Enum s -> "enum", Some s
  | EnumValue s -> "enum_value", Some s

  | EndCompound -> "end_compound", None
  | IfdefElse -> "ifdef_else", None
  | IfdefEndif -> "ifdef_endif", None
  | EndOfFile -> "end_eof", None
  | Else -> "end_else", None

  | Statement st -> 
      (match st with
      | If -> "if", None
      | Loop -> "loop", None

      | SimpleFunCall s -> "funcall", Some s
      | MethodCall s -> "methodcall", Some s

      | SimpleAssign s -> "assign", Some s
      | SimpleFieldAssign s -> "assignfield", Some s
      | SimpleAssignOp op -> ("assignop_" ^ s_of_arithop op), None
      | SimpleIncDec op -> "incdec", None

      | Label s -> "label", Some s
      | Case sopt -> "case", sopt

      | Goto s -> "goto", Some s
      | Continue -> "continue", None  | Break -> "break", None
      | Return -> "return", None


      | Compound -> "compound", None

      | StatementUnknown -> "statement_misc", None
      )

  | Expression e -> 
      (match e with
      | Binary op -> "op", None
      | ExpressionUnknown -> "exp_misc", None
      )



  | InInitializerUnknown -> "initalizer_misc", None
  | InStructUnknown -> "struct_misc", None
  | InEnumUnknown -> "enum_misc", None
  | InFuncUnknown -> "function_misc", None

  | Unknown -> "unknown", None
  | Fake -> "fake", None

